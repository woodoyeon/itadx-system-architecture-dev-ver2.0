#  서버가 보내는 실시간 이벤트를 듣는 부분ItaDX — 프론트↔백 통신

**바로가기**

- [프론트→백 REST API 통신](#1-프론트엔드--백엔드-rest-api-통신)
- [요청/응답 JSON 규칙](#2-요청응답-json--프론트가-보내는-것-백이-받고-돌려주는-것)
- [WebSocket 실시간 알림 예시](#3-websocket-실시간-알림-입고확인-예시)

---

## 1. 프론트엔드 → 백엔드 (REST API) 통신

### ① 흐름도 (한눈에 보기)

```
  [화면]          [Next.js]         [Gateway]          [실제 API 서버]
    │                 │                  │                      │
    │  "로그인해줘"     │                  │                      │
    │  api.post(...)   │                  │                      │
    │ ────────────────>│  /api 요청       │                      │
    │                  │                  │                      │
    │                  │ ────────────────>│  URL 보고 어디로 갈지 결정
    │                  │                  │  /api/auth → 4001     │
    │                  │                  │  /api/receivings→4002 │
    │                  │                  │ ────────────────────>│  auth-api
    │                  │                  │                      │  erp-api 등
    │                  │                  │  <────────────────────│  응답
    │                  │  <───────────────│                      │
    │  <───────────────│  응답 전달       │                      │
    │  화면 갱신        │                  │                      │
```

**한 줄 요약:** 프론트는 항상 `/api/...` 만 부르고, Next가 Gateway(4003)로 넘기고, Gateway가 경로에 따라 auth(4001)·admin(4000)·erp(4002)로 나눠서 보냅니다.

---

### ② 프론트:

프론트에서는 **axios 인스턴스 하나**로 모든 백엔드 요청을 보냅니다. 주소는 `/api`로 시작하기만 하면 됩니다.

**파일:** [apps/admin-web/src/lib/api.ts](../apps/admin-web/src/lib/api.ts)

```ts
const api = axios.create({
  baseURL: '/api',   // ← 항상 /api 로 시작 (실제 서버 주소는 몰라도 됨)
  timeout: 10000,
  headers: { 'Content-Type': 'application/json' },
});

// 매 요청마다 JWT 자동으로 붙임
api.interceptors.request.use((config) => {
  const token = useAuthStore.getState().accessToken;
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});
```

- **통신 요약:** 브라우저는 `api.get('/auth/profile')`, `api.patch('/receivings/123/confirm')` 처럼 `**/api` + 경로**만 호출합니다. JWT는 위 인터셉터가 자동으로 붙입니다.

---

### ③ Next: "/api 로 오는 건 Gateway로 보낸다"

브라우저가 보낸 `/api/...` 요청을 **그대로** Gateway(4003)로 넘깁니다. 프론트 코드는 localhost:4003을 몰라도 됩니다.

**파일:** [apps/admin-web/next.config.js](../apps/admin-web/next.config.js)

```js
async rewrites() {
  return [
    { source: '/api/:path*', destination: 'http://localhost:4003/api/:path*' },
  ];
}
```

- **통신 요약:** `GET /api/receivings` → 실제로는 `GET http://localhost:4003/api/receivings` 로 전달됩니다.

---

### ④ Gateway: "경로 보고 어느 서버로 보낼지 정한다"

Gateway는 **URL 앞부분**만 보고 auth / admin / erp 중 하나로 요청을 넘깁니다.

**파일:** [services/gateway-api/src/proxy/proxy.middleware.ts](../services/gateway-api/src/proxy/proxy.middleware.ts)

```ts
private readonly routes: Record<string, string> = {
  '/api/auth':       'http://localhost:4001',   // 로그인, 프로필, refresh
  '/api/marts':      'http://localhost:4000',   // 마트/지점/가맹점/대시보드
  '/api/receivings': 'http://localhost:4002',   // 입고 목록, 입고확인
  '/api/settlements': 'http://localhost:4002',  // 정산
  // ...
};

// 요청 경로가 위 prefix 중 하나로 시작하면 → 해당 서버로 프록시
const target = Object.entries(this.routes).find(([prefix]) => path.startsWith(prefix));
// → createProxyMiddleware로 그대로 전달
```

- **통신 요약:**  
  - `/api/auth/login` → **auth-api (4001)**  
  - `/api/receivings` → **erp-api (4002)**  
  - `/api/marts`, `/api/users` 등 → **admin-api (4000)**

---

### ⑤ 예: 로그인 (프론트 → 백 순서)


| 단계  | 어디서                                                                                                         | 하는 일                                              |
| --- | ----------------------------------------------------------------------------------------------------------- | ------------------------------------------------- |
| 1   | [apps/admin-web/src/app/login/page.tsx](../apps/admin-web/src/app/login/page.tsx)                           | `api.post('/auth/login', { email, password })` 호출 |
| 2   | [apps/admin-web/src/lib/api.ts](../apps/admin-web/src/lib/api.ts)                                           | `POST /api/auth/login` + (로그인 후) JWT 자동 첨부        |
| 3   | [apps/admin-web/next.config.js](../apps/admin-web/next.config.js)                                           | `/api/`* → Gateway(4003)로 rewrite                 |
| 4   | [services/gateway-api/src/proxy/proxy.middleware.ts](../services/gateway-api/src/proxy/proxy.middleware.ts) | `/api/auth` → auth-api(4001)로 프록시                 |
| 5   | [services/auth-api/src/auth/auth.controller.ts](../services/auth-api/src/auth/auth.controller.ts)           | `@Post('login')` → 토큰 발급 후 응답                     |


**로그인 시 핵심 코드 (프론트):**

```ts
// login/page.tsx
const { data } = await api.post('/auth/login', { email, password });
setTokens(data.data.accessToken, data.data.refreshToken);
const profile = await api.get('/auth/profile');  // JWT가 자동으로 붙음
```

**로그인 시 핵심 코드 (백):**

```ts
// auth.controller.ts
@Post('login')
async login(@Body() dto: LoginDto) {
  const tokens = await this.authService.login(dto);
  return createResponse(tokens);
}
```

---

### ⑥ 예: 입고 목록·입고확인 (프론트 → 백 순서)


| 단계  | 어디서                                                                                                                 | 하는 일                                                             |
| --- | ------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| 1   | [apps/admin-web/src/hooks/use-receivings.ts](../apps/admin-web/src/hooks/use-receivings.ts)                         | `api.get('/receivings')`, `api.patch('/receivings/:id/confirm')` |
| 2   | Next → Gateway                                                                                                      | `/api/receivings` → Gateway(4003)                                |
| 3   | Gateway                                                                                                             | `/api/receivings` → erp-api(4002)                                |
| 4   | [services/erp-api/src/receiving/receiving.controller.ts](../services/erp-api/src/receiving/receiving.controller.ts) | `@Get()`, `@Patch(':id/confirm')` → Service 호출                   |


**입고 조회 (프론트):**

```ts
// use-receivings.ts
const { data } = await api.get('/receivings', { params: filters });


실제 요청:
GET /api/receivings?martId=123&status=pending&page=1

```

**입고확인 (백 컨트롤러):**

```ts
// receiving.controller.ts
@Patch(':id/confirm')
async confirm(@Param('id') id: string, @CurrentUser() user: UserPayload) {
  return createResponse(await this.receivingService.confirmReceiving(id, user));
}


```

---

## 2. 요청/응답 JSON — 프론트가 보내는 것, 백이 받고 돌려주는 것

**프론트 개발자는 이 규칙만 지키면 됩니다.**  
새 API를 만들 때도 **같은 형식**으로 요청을 보내고, 응답도 **같은 형식**으로 처리하면 됩니다.

### ① 전체 규칙 (모든 API 공통)


| 구분         | 형식                                                                                       | 설명                      |
| ---------- | ---------------------------------------------------------------------------------------- | ----------------------- |
| **성공 응답**  | `{ "success": true, "data": ... }`                                                       | 실제 데이터는 항상 `data` 안에 있음 |
| **목록+페이지** | `{ "success": true, "data": [...], "meta": { "page", "limit", "total", "totalPages" } }` | 목록 API는 `meta`로 페이지 정보  |
| **실패 응답**  | `{ "success": false, "error": { "code": "에러코드", "message": "메시지" } }`                    | 4xx/5xx 시 이 구조          |


- 백엔드 공통 타입: [libs/common/src/types/api-response.ts](../libs/common/src/types/api-response.ts)  
- 프론트 타입(같은 구조): [apps/admin-web/src/types/index.ts](../apps/admin-web/src/types/index.ts)

---

### ② 예시 1: 로그인 — 프론트가 JSON 보내고, 백이 JSON 돌려줌

**프론트 → 백 (요청)**

- **메서드/URL:** `POST /api/auth/login`
- **헤더:** `Content-Type: application/json` (로그인은 JWT 없음)
- **바디 (JSON):**

```json
{
  "email": "admin@itadx.com",
  "password": "password123"
}
```

- **프론트 코드:** [apps/admin-web/src/app/login/page.tsx](../apps/admin-web/src/app/login/page.tsx)  
`api.post('/auth/login', { email, password })`
- **백이 받는 DTO:** [services/auth-api/src/auth/dto/login.dto.ts](../services/auth-api/src/auth/dto/login.dto.ts)  
`email`, `password` 검증 후 Service로 전달

**백 → 프론트 (응답)**

- **성공 시 (200):**

```json
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIs...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIs..."
  }
}
```

- **백 코드:** [services/auth-api/src/auth/auth.controller.ts](../services/auth-api/src/auth/auth.controller.ts)  
`return createResponse(tokens);` → 위 형식으로 자동 래핑
- **프론트 사용:** `data.data.accessToken`, `data.data.refreshToken` 저장 후 이후 요청에 JWT 첨부

**실패 시 (401):**

```json
{
  "success": false,
  "error": {
    "code": "INVALID_CREDENTIALS",
    "message": "이메일 또는 비밀번호가 올바르지 않습니다."
  }
}
```

→ 프론트는 `data.success` / `data.error` 로 분기하면 됨.

---

### ③ 예시 2: 입고 목록 조회 — query로 조건 보내고, 목록+meta 받음

**프론트 → 백 (요청)**

- **메서드/URL:** `GET /api/receivings?martId=xxx&status=pending&page=1&limit=20`
- **헤더:** `Authorization: Bearer <accessToken>` (api 인스턴스가 자동 첨부)
- **바디:** 없음 (GET)
- **프론트 코드:** [apps/admin-web/src/hooks/use-receivings.ts](../apps/admin-web/src/hooks/use-receivings.ts)  
`api.get('/receivings', { params: filters })`  
→ `filters`가 query string으로 붙음

**백 → 프론트 (응답)**

- **성공 시 (200):**

```json
{
  "success": true,
  "data": [
    {
      "id": "uuid-1",
      "merchantId": "uuid-m",
      "martId": "uuid-mart",
      "receivingDate": "2025-02-26",
      "totalAmount": 1000000,
      "items": [],
      "status": "pending",
      "confirmedAt": null
    }
  ],
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 45,
    "totalPages": 3
  }
}
```

- **백 코드:** [services/erp-api/src/receiving/receiving.controller.ts](../services/erp-api/src/receiving/receiving.controller.ts)  
`createPaginatedResponse(result.items, result.total, result.page, result.limit)`  
→ [libs/common/src/types/api-response.ts](../libs/common/src/types/api-response.ts) 의 공통 형식
- **프론트 사용:** `data.data` = 목록 배열, `data.meta` = 페이지 정보 (무한 스크롤/페이지네이션)

---

### ④ 예시 3: 입고확인 — URL로 id 보내고, 갱신된 한 건 받음

**프론트 → 백 (요청)**

- **메서드/URL:** `PATCH /api/receivings/:id/confirm` (예: `PATCH /api/receivings/uuid-123/confirm`)
- **헤더:** `Authorization: Bearer <accessToken>`
- **바디:** 없음 (또는 `{}`)
- **프론트 코드:** [apps/admin-web/src/hooks/use-receivings.ts](../apps/admin-web/src/hooks/use-receivings.ts)  
`api.patch(\`/receivings/${id}/confirm)`

**백 → 프론트 (응답)**

- **성공 시 (200):**

```json
{
  "success": true,
  "data": {
    "id": "uuid-123",
    "merchantId": "uuid-m",
    "martId": "uuid-mart",
    "status": "confirmed",
    "confirmedAt": "2025-02-26T10:30:00.000Z",
    "confirmedBy": "user-uuid",
    "totalAmount": 1000000
  }
}
```

- **백 코드:** [services/erp-api/src/receiving/receiving.controller.ts](../services/erp-api/src/receiving/receiving.controller.ts)  
`return createResponse(await this.receivingService.confirmReceiving(id, user));`

→ 프론트는 `data.data` 에 갱신된 입고 한 건이 들어온다고 보면 됨.

---

## 3. WebSocket 실시간 알림 (입고확인 예시)

WebSocket은 ItaDX에서 보통 **3단계**로 끝납니다.

1. **Gateway(WebSocket 서버)** 가 연결을 받아서 역할별 room에 넣고
2. **Service** 가 비즈니스 로직이 끝나는 지점에서 `emit` ((이벤트 발생시키는 것) )으로 이벤트를 발송하고
3. **프론트** 는 해당 이벤트를 `on` 으로 듣고 **리스트·대시보드 캐시만 무효화**합니다.

### ① 백엔드: WebSocket Gateway

**파일(예시):** [libs/websocket/src/gateways/notification.gateway.ts](../libs/websocket/src/gateways/notification.gateway.ts)

```ts
@WebSocketGateway({
  namespace: '/',
  cors: { origin: true },
})
export class NotificationGateway implements OnGatewayConnection {
  @WebSocketServer()
  server!: Server;
  
  //“Gateway(WebSocket 서버)가 연결을 받아서 역할별 room에 넣는” 부분
  async handleConnection(@ConnectedSocket() socket: Socket) {
    const role = socket.handshake.auth?.role; // 'bank' | 'mart' | 'admin'
    if (role) socket.join(role);
  }

  notifyBank(event: string, data: unknown) {
    this.server.to('bank').emit(event, data);
  }
}
```

- **요약:** `server.to('bank').emit('receiving:confirmed', 데이터);` → 은행만 받는 실시간 이벤트.

### ② 백엔드: Service에서 이벤트 emit

**파일(예시):** [services/erp-api/src/receiving/receiving.service.ts](../services/erp-api/src/receiving/receiving.service.ts)

```ts
export class ReceivingService {
  constructor(private readonly wsGateway: NotificationGateway) {}

  async confirmReceiving(id: string, user: any) {
    // 1) DB에서 입고 상태를 confirmed 로 변경

    // 2) WebSocket 이벤트 발송
    this.wsGateway.notifyBank('receiving:confirmed', {
      receivingId: id,
      confirmedBy: user.email,
      confirmedAt: new Date().toISOString(),
    });

    // 3) HTTP 응답 리턴
    return { id, status: 'confirmed' };
  }
}
```

- **요약:** **HTTP 응답(return)** 과 **WebSocket emit** 이 같은 시점에 일어납니다.

### ③ 프론트: socket 연결 + 이벤트 수신

**파일(예시):** [apps/admin-web/src/lib/socket.ts](../apps/admin-web/src/lib/socket.ts)

```ts

//현재 접속한 서버 주소로 소켓 연결을 시도합니다.
export const socket = io(window.location.origin, {
  transports: ['websocket'],
  auth: {
    token: useAuthStore.getState().accessToken,
    role: useAuthStore.getState().role, // 예: 'bank'
  },
});
```

**파일(예시):** [apps/admin-web/src/hooks/use-socket.ts](../apps/admin-web/src/hooks/use-socket.ts)

```ts
export function useSocket() {
  const queryClient = useQueryClient();

  useEffect(() => {
    const onConfirmed = () => {
      queryClient.invalidateQueries({ queryKey: ['receivings'] });
      queryClient.invalidateQueries({ queryKey: ['dashboard'] });
    };
     
    //서버가 보내는 실시간 이벤트를 듣는 부분
    socket.on('receiving:confirmed', onConfirmed);
    return () => socket.off('receiving:confirmed', onConfirmed);
  }, [queryClient]);
}
```

---

docs파일:

- 작성자: 우도연 본부장  
- 최종 수정일: 2026-02-27  
- 버전: v1.0

코드 변경 이력: 

2026-02-27  
변경자: 우도연 (AI본부장)  
브랜치: feature/auth-login  
커밋: a8f31d2  
내용:  

- 로그인 API 구현  
- JWT 인터셉터 적용  
- 공통 API 응답 구조 적용

